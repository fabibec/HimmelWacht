/**
 * This file is mostly generated by Claude AI.
 * It is used to test the differential drive functionality.
 * It initializes the motors and runs a sequence of movements.
 * 
 * Currently the code will no longer run. However, the basic ideas should be presented.
 * @author Claude AI, Michael Specht
 */

#include "sdkconfig.h"
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_log.h"
#include "driver/gpio.h"
#include "diff-drive.h"
#include "motor-driver.h"

static const char *TAG = "DIFF_DRIVE_TEST";

// Define GPIO pins for motors
#define LEFT_MOTOR_PWM_GPIO   23
#define LEFT_MOTOR_DIR_GPIO   22
#define LEFT_MOTOR_FAULT_GPIO 21
#define LEFT_MOTOR_FAULT_LED  19

#define RIGHT_MOTOR_PWM_GPIO   27
#define RIGHT_MOTOR_DIR_GPIO   26
#define RIGHT_MOTOR_FAULT_GPIO 25
#define RIGHT_MOTOR_FAULT_LED  32

// Define movement parameters
#define MAX_INPUT_VALUE    512
#define MOVEMENT_TIME_MS   3000  // 5 seconds per movement
#define CENTER_VALUE       0
#define FORWARD_VALUE      250
#define BACKWARD_VALUE     (-250)
#define LEFT_TURN_VALUE    (-170)  
#define RIGHT_TURN_VALUE   170     

// Differential drive configuration
static diff_drive_config_t diff_drive_config = {
    .max_input = MAX_INPUT_VALUE,
    .cmd_queue_size = 10,
    .recovery_time_ms = 1000,
    .task_priority = 10,
    .task_stack_size = 4096,
    .task_core_id = 0,
    .task_delay_ms = 20,
    .queue_timout_ms = 50,
};

// Left motor configuration
static motor_config_t left_motor_config = {
    .mcpwm_unit = MCPWM_UNIT_0,
    .timer_num = MCPWM_TIMER_0,
    .generator = MCPWM_OPR_A,
    .pwm_signal = MCPWM0A,
    .pwm_gpio_num = LEFT_MOTOR_PWM_GPIO,
    .dir_gpio_num = LEFT_MOTOR_DIR_GPIO,
    .fault_gpio_num = LEFT_MOTOR_FAULT_GPIO,
    .fault_led_gpio_num = LEFT_MOTOR_FAULT_LED,
    .pwm_frequency_hz = 20000,
    .ramp_rate = 5,         // Adjust as needed
    .ramp_intervall_ms = 10, // Adjust as needed
    .direction_hysteresis = 5, // Adjust as needed
    .pwm_duty_limit = 50
};

// Right motor configuration 
static motor_config_t right_motor_config = {
    .mcpwm_unit = MCPWM_UNIT_0,
    .timer_num = MCPWM_TIMER_1,
    .generator = MCPWM_OPR_A,
    .pwm_signal = MCPWM1A,
    .pwm_gpio_num = RIGHT_MOTOR_PWM_GPIO,
    .dir_gpio_num = RIGHT_MOTOR_DIR_GPIO,
    .fault_gpio_num = RIGHT_MOTOR_FAULT_GPIO,
    .fault_led_gpio_num = RIGHT_MOTOR_FAULT_LED,
    .pwm_frequency_hz = 20000,
    .ramp_rate = 5,         // Adjust as needed
    .ramp_intervall_ms = 10, // Adjust as needed
    .direction_hysteresis = 5, // Adjust as needed
    .pwm_duty_limit = 50
};

// Function to send movement command with logging
void send_movement_command(diff_drive_handle_t *diff_drive, int16_t x, int16_t y, const char *movement_name) {
    ESP_LOGI(TAG, "Starting movement: %s (x=%d, y=%d)", movement_name, x, y);
    
    input_matrix_t matrix = {
        .x = x,
        .y = y
    };
    
    esp_err_t ret = diff_drive_send_cmd(diff_drive, &matrix);
    if (ret != ESP_OK) {
        ESP_LOGE(TAG, "Failed to send command: %s", esp_err_to_name(ret));
    }
}

// Task to run the test sequence
void test_sequence_task(void *pvParameters) {
    diff_drive_handle_t *diff_drive = (diff_drive_handle_t *)pvParameters;
    
    // Give system time to stabilize
    vTaskDelay(pdMS_TO_TICKS(10000));
    
    // 1. Drive forward for 5 seconds
    send_movement_command(diff_drive, CENTER_VALUE, FORWARD_VALUE, "FORWARD");
    vTaskDelay(pdMS_TO_TICKS(MOVEMENT_TIME_MS));
    
    // 2. Drive backward for 5 seconds
    send_movement_command(diff_drive, CENTER_VALUE, BACKWARD_VALUE, "BACKWARD");
    vTaskDelay(pdMS_TO_TICKS(MOVEMENT_TIME_MS));
    
    // 3. Drive forward with left steering for 5 seconds
    send_movement_command(diff_drive, LEFT_TURN_VALUE, FORWARD_VALUE, "FORWARD LEFT");
    vTaskDelay(pdMS_TO_TICKS(MOVEMENT_TIME_MS));
    
    // 4. Drive backward for 5 seconds
    send_movement_command(diff_drive, CENTER_VALUE, BACKWARD_VALUE, "BACKWARD");
    vTaskDelay(pdMS_TO_TICKS(MOVEMENT_TIME_MS));
    
    // 5. Drive forward with right steering for 5 seconds
    send_movement_command(diff_drive, RIGHT_TURN_VALUE, FORWARD_VALUE, "FORWARD RIGHT");
    vTaskDelay(pdMS_TO_TICKS(MOVEMENT_TIME_MS));
    
    // 6. Drive backward for 5 seconds
    send_movement_command(diff_drive, CENTER_VALUE, BACKWARD_VALUE, "BACKWARD");
    vTaskDelay(pdMS_TO_TICKS(MOVEMENT_TIME_MS));
    
    // Stop the motors
    send_movement_command(diff_drive, CENTER_VALUE, CENTER_VALUE, "STOP");
    vTaskDelay(pdMS_TO_TICKS(1000));
    
    // Test complete
    ESP_LOGI(TAG, "Differential drive test complete");
    
    // Properly deinitialize
    ESP_LOGI(TAG, "Deinitializing differential drive");
    diff_drive_deinit(diff_drive);
    
    // Delete this task
    vTaskDelete(NULL);
}

void app_main1(void) {
    ESP_LOGI(TAG, "Differential Drive Test Starting");
    
    // Initialize differential drive
    diff_drive_handle_t *diff_drive = diff_drive_init(&diff_drive_config, 
                                                     &left_motor_config, 
                                                     &right_motor_config);
    
    if (diff_drive == NULL) {
        ESP_LOGE(TAG, "Failed to initialize differential drive");
        return;
    }
    
    ESP_LOGI(TAG, "Differential drive initialized successfully");
    
    // Create a separate task for the test sequence
    xTaskCreate(test_sequence_task, "test_sequence", 4096, diff_drive, 4, NULL);
    
    // Main task can do other work or just wait
    while(1) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}